---
sidebar_position: 16
sidebar_label: "Glossary"
title: Glossary
---

### Asset

An asset is a resource that is valuable to an organization. In the context of Scribe, an asset is a target from which you want to collect evidence. This could be an image, a file, a GIT repository, or a platform discovery target, like GitHub organization configuration or a K8s pod instance.

### Code Integrity Validation

Code Integrity Validation is a test that verifies that files were not modified unlawfully between the source repository and the final image. In Scribe this test uses hash values generated during the evidence collection and so doesn't require looking at the actual code. Even a single bit changed in a file would generate a different hash value so by comparing hash values generated by files in the source repository and the ones in the final image we're able to identify and files that do not match.

### CycloneDX

OWASP CycloneDX is a lightweight Bill of Materials (BOM) standard designed for use in application security contexts and supply chain component analysis. The specification excels in: Software Bill of Materials (SBOM) Software-as-a-Service Bill of Materials (SaaSBOM), and Operations Bill of Materials (OBOM).

You can read more about CycloneDX SBOM [here](https://cyclonedx.org/capabilities/sbom/ "OWASP CycloneDX SBOM").

### Dependencies

A software dependency is a code library or package that is reused in a new piece of software. For example, a machine learning project written in Python might call a Python library to build models. The benefit of software dependencies is that they allow developers to more quickly deliver software by building on previous work. Most code dependencies are open source packages. Transitive dependencies are referring to 'a dependency of a dependency'. Since most code is built using other libraries that is true for your dependencies as well. That means that your dependencies have their own dependencies and so on down the line. This chain of dependencies is part of what is known as the software supply chain.

### DevSecOps

DevSecOps stands for development + security + operations. It's an approach that combines application development, security, operations and infrastructure as code (IaC) in an automated continuous integration/continuous delivery (CI/CD) pipeline.

### Evidence

In this context, evidence is proof of something that happened (or didn't happen) during the development process and/or build pipeline. This evidence would usually take the form of a log or file. In order to make sure that the evidence is trustworthy and unfalsifiable, it is considered a best practice to sign it cryptographically to turn it into an attestation.

### Evidence collection target

Scribe knows how to collect evidence from several entities:
* An image - Image formats supported are currently docker manifest v2 and Oracle Cloud Infrastructure (OCI)
* A folder
* A file
* A GIT repository - A remote/local GIT repository  

Targeting one of these entities with the Scribe tool allows you to collect evidence about that target. That evidence might be slightly different depending on the selected target. The evidence collected could include an SBOM in the OWASP CycloneDX format and SLSA Provenance. The evidence might be standalone or packaged as either an in-toto attestation or an in-toto statement. The evidence collected includes context information - what is the environment in which the evidence collection took place, which process called the collector etc. Environment context is key to connecting evidence not only to the target but to its origin in your supply chain (provenance).

You can view which environments are supported by Scribe's tool [here](how-to-run-scribe/ci-integrations/ "integrating Scribe into a pipeline").

### Hash Value

A hash value is a numeric value of a fixed length that uniquely identifies data. Hash values represent large amounts of data as much smaller numeric values. Since each piece of data generates a unique hash value these strings can be used in algorithms comparing data pieces or files. 

### In-toto

In-toto is a framework built to secure the integrity of software supply chains. The framework was designed for securing the way in which software is developed, built, tested, and packaged (i.e., the software supply chain). In-toto attests to the integrity and verifiability of all the actions performed while writing code, compiling, testing, and deploying software. It does so by making it transparent to the user what steps were performed, by whom and in what order. As a result, given guidance by the group creating the software, in-toto allows the user to verify if a step in the supply chain was intended to be performed, if the step was performed by the right actor, and attests that materials (e.g., source code) were not tampered with between steps.

You can read more about in-toto [here](https://in-toto.io/ "in-toto framework"). 

### In-toto Attestation

An attestation is cryptographically signed piece of evidence. It's a mechanism for software to prove its identity and authenticity. The goal of attestation is to prove to a third party that the signed evidence is intact and trustworthy. An [in-toto attestation](https://github.com/in-toto/attestation "in-toto attestation GitHub link") is authenticated (cryptographically signed) metadata about one or more software artifacts, as per the [SLSA Attestation Model](https://github.com/slsa-framework/slsa/blob/main/docs/attestation-model.md "SLSA Attestation Model GitHub link").

### In-toto Statement

An in-toto Statement is almost identical to an in-toto attestation. The only difference is that the in-toto Statement is not cryptographically signed. Other than that it's packaged in exactly the same way as an  [in-toto attestation](https://github.com/in-toto/attestation "in-toto attestation GitHub link").

### Policy Bundle

A policy bundle is a collection of [rules](#policy-rule) and [initiatives](#policy-initiative) that can be used to evaluate evidence. For example, a policy bundle could be a collection of security frameworks that are used to evaluate the security posture of an application. Scribe provides a [Sample Policy Bundle](https://github.com/scribe-public/sample-policies) that includes the SSDF, SLSA L1 and L2 frameworks as well as a set of rules to verify a variety of security requirements on different types of attestations.

### Policy Initiative

An initiative is a high-level, abstract requirement that is comprised of a set of [controls](#policy-control). For example, a security framework such as SSDF can be represented as an initiative.

### Policy Control

A control is an abstract requirement that is comprised of a set of [rules](#policy-rule). For example, the SSDF framework (initiative) requires a control for protecting access to the source code.

### Policy Rule

A rule is a single requirement that is, in the context of Scribe, a single check that can be performed on evidence. For example, the control described in the section above can be materialized by requiring MFA, limiting the number and identity of admins, and requiring the source code repository to be private -- each of these requirements is a rule.

### SBOM

The software bill of materials (SBOM) lists all component parts and software dependencies involved in the development and delivery of an application. SBOMs are similar to bill of materials (BOMs) used in supply chains and manufacturing. There hasn’t been a common feature for all vendors in the IT industry to accurately describe the foundational code components on which an application is built.

A typical SBOM would include licensing information, version numbers, component details, and vendors. A formal list of all the facts decreases risks for both the manufacturer and the user by allowing others to understand what’s in their software and act accordingly. SBOMs aren’t new to the software industry, but they’re becoming increasingly vital as development becomes more sophisticated and expensive. They’ve lately become a basic requirement in a number of businesses.

You can read more about it [here](https://scribesecurity.com/sbom/ "Read more about SBOM").

### SLSA

The Supply chain Levels for Software Artifacts or SLSA (pronounced Salsa) is a security framework created by Google. It is a list of standards and controls meant to prevent tampering, improve file integrity, and secure packages and infrastructure in your projects, businesses, or enterprises. 
SLSA consists of common-sense security measures intended for embedding security throughout the development lifecycle. 
SLSA is meant to make it easier for the implementing organization to get information about its software source, build, and artifacts. At the same time, it’s meant to make it much harder for any malicious or threat actor, either within or outside of the organization, to make any unauthorized changes to files, processes, or artifacts.

You can read more about SLSA [here](https://slsa.dev/ "SLSA").

### SLSA Provenance

Provenance is the place of origin or earliest known history of something. SLSA provenance is a claim that some entity produced one or more software artifacts by executing some recipe or procedure, using some other artifacts as input built to the SLSA standard. It’s the verifiable information about software artifacts describing where, when and how something was produced. 

You can read more about SLSA provenance and it's structure [here](https://slsa.dev/provenance/v0.2 "SLSA Provenance").

### Software Supply Chain

The software supply chain refers to everything involved in the development of an application throughout the entire software development life cycle (SDLC). There are many factors to consider in this regard, including custom code (in-house components), open source dependencies and libraries (third-party components), DevOps tools and infrastructure that make up the CI/CD process, and finally developers and DevOps teams.      

You can read more about it [here](https://scribesecurity.com/software-supply-chain-security/ "Read more about Software Supply Chain").

<!---
### Verbose
Verbose mode is an option that provides additional details as to what the command used is doing. Usually, the higher the verbose value, the more details the command will provide. A higher verbose value is often used in debugging mode.
--->
